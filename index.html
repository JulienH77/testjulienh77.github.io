<!DOCTYPE html>
<html>
<head>
    <title>Animation Fluide de Polyline avec Leaflet</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <style>
        #map { height: 600px; margin-bottom: 10px; }
        button { margin: 5px; padding: 8px 12px; cursor: pointer; }
        #log { margin-top: 10px; color: #666; font-family: monospace; }
    </style>
</head>
<body>
    <div id="map"></div>
    <button id="testAnimation">Tester une animation fluide</button>
    <button id="showStatic">Afficher les géométries en statique</button>
    <div id="log">Chargement du GeoJSON...</div>

    <script>
        // Initialisation de la carte avec OSM
        const map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Variables pour stocker les polylines
        let activePolylines = [];
        let staticPolylines = [];
        let geoJsonData = null;

        // Fonction pour supprimer toutes les polylines actives
        function clearActivePolylines() {
            activePolylines.forEach(polyline => map.removeLayer(polyline));
            activePolylines = [];
        }

        // Fonction pour supprimer les polylines statiques
        function clearStaticPolylines() {
            staticPolylines.forEach(polyline => map.removeLayer(polyline));
            staticPolylines = [];
        }

        // Fonction pour calculer la longueur d'une polyline en km
        function calculateLineLength(latlngs) {
            let length = 0;
            for (let i = 1; i < latlngs.length; i++) {
                const p1 = latlngs[i - 1];
                const p2 = latlngs[i];
                const dx = p2.lng - p1.lng;
                const dy = p2.lat - p1.lat;
                // Approximation de la distance en km (formule de Haversine simplifiée)
                const lat1 = p1.lat * Math.PI / 180;
                const lat2 = p2.lat * Math.PI / 180;
                const lon1 = p1.lng * Math.PI / 180;
                const lon2 = p2.lng * Math.PI / 180;
                const dLat = lat2 - lat1;
                const dLon = lon2 - lon1;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                          Math.cos(lat1) * Math.cos(lat2) *
                          Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                const R = 6371; // Rayon de la Terre en km
                length += R * c;
            }
            return length;
        }

        // Fonction pour animer une polyline avec une vitesse constante (km/s)
        function animatePolyline(latlngs, color, speedKmPerSecond, onComplete) {
            const lengthKm = calculateLineLength(latlngs);
            const durationMs = (lengthKm / speedKmPerSecond) * 1000; // Durée en ms
            const polyline = L.polyline([latlngs[0]], { color: color, weight: 4 }).addTo(map);
            activePolylines.push(polyline);

            let startTime;
            function animate(currentTime) {
                if (!startTime) startTime = currentTime;
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / durationMs, 1);
                const numPoints = Math.floor(progress * (latlngs.length - 1)) + 1;
                const partialProgress = (progress * (latlngs.length - 1)) % 1;
                const points = latlngs.slice(0, numPoints);

                if (numPoints < latlngs.length) {
                    const startPoint = latlngs[numPoints - 1];
                    const endPoint = latlngs[numPoints];
                    const interpolatedPoint = L.latLng(
                        startPoint.lat + (endPoint.lat - startPoint.lat) * partialProgress,
                        startPoint.lng + (endPoint.lng - startPoint.lng) * partialProgress
                    );
                    points.push(interpolatedPoint);
                }
                polyline.setLatLngs(points);
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else if (onComplete) {
                    onComplete();
                }
            }
            requestAnimationFrame(animate);
        }

        // Fonction pour extraire les LineString d'un MultiLineString
        function extractLineStrings(multiLineString) {
            return multiLineString.coordinates.map(line => line.map(coord => L.latLng(coord[1], coord[0])));
        }

        // Chargement du fichier GeoJSON
        fetch('TRAJETS_ALL_vacances_wgs.geojson')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Erreur HTTP ! statut : ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                geoJsonData = data;
                document.getElementById('log').textContent = `GeoJSON chargé : ${data.features.length} entités.`;

                // Bouton pour afficher les géométries en statique
                document.getElementById('showStatic').addEventListener('click', () => {
                    clearStaticPolylines();
                    clearActivePolylines();

                    const bounds = [];
                    data.features.forEach(feature => {
                        if (feature.geometry.type === 'MultiLineString') {
                            const lineStrings = extractLineStrings(feature.geometry);
                            lineStrings.forEach(latlngs => {
                                bounds.push(...latlngs);
                                const polyline = L.polyline(latlngs, { color: '#808080', weight: 2 }).addTo(map);
                                staticPolylines.push(polyline);
                            });
                        }
                    });

                    if (bounds.length > 0) {
                        map.fitBounds(bounds);
                    }
                });

                // Bouton pour tester une animation fluide
                document.getElementById('testAnimation').addEventListener('click', () => {
                    clearActivePolylines();

                    // Trie les features par ordre de "id"
                    const sortedFeatures = data.features.sort((a, b) => a.properties.id - b.properties.id);
                    const speedKmPerSecond = 30; // Vitesse constante en km/s

                    // Animation séquentielle de chaque feature
                    let currentIndex = 0;
                    function animateNextFeature() {
                        if (currentIndex >= sortedFeatures.length) return;

                        const feature = sortedFeatures[currentIndex];
                        if (feature.geometry.type === 'MultiLineString') {
                            const lineStrings = extractLineStrings(feature.geometry);
                            const trajet = feature.properties.trajet;
                            let color;
                            switch (trajet) {
                                case 'avion': color = '#FF0000'; break;
                                case 'train': color = '#00FF00'; break;
                                case 'bateau': color = '#0000FF'; break;
                                default: color = '#808080';
                            }

                            // Anime chaque segment de la feature
                            let segmentIndex = 0;
                            function animateNextSegment() {
                                if (segmentIndex >= lineStrings.length) {
                                    currentIndex++;
                                    animateNextFeature();
                                    return;
                                }

                                const latlngs = lineStrings[segmentIndex];
                                animatePolyline(latlngs, color, speedKmPerSecond, () => {
                                    segmentIndex++;
                                    animateNextSegment();
                                });
                            }

                            animateNextSegment();
                        } else {
                            currentIndex++;
                            animateNextFeature();
                        }
                    }

                    animateNextFeature();
                });
            })
            .catch(error => {
                document.getElementById('log').textContent = `Erreur : ${error.message}`;
                console.error('Erreur de chargement du GeoJSON:', error);
            });
    </script>
</body>
</html>
