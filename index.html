<!DOCTYPE html>
<html>
<head>
    <title>Animation des trajets avec L.Motion</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet.motion/dist/leaflet.motion.min.js"></script>
    <style>
        html, body, #map { width: 100%; height: 100%; margin: 0px; padding: 0px; }
        #controls { position: absolute; z-index: 1000; top: 10px; left: 10px; background: white; padding: 10px; border-radius: 5px; }
        select, button { margin-right: 5px; }
        .leaflet-control-zoom { display: none !important; }
        #info-banner {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
            text-align: center;
            font-family: Arial, sans-serif;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            min-width: 300px;
        }
        #info-banner .dates { font-size: 16px; margin-bottom: 5px; }
        #info-banner .duration { font-size: 20px; font-weight: bold; margin: 5px 0; }
        #info-banner .distance { font-size: 14px; color: #555; }
        #info-banner .recap { font-size: 16px; font-weight: bold; color: #0066cc; margin-top: 10px; }

        /* --- Ajouts : contrôles et barre de progression en bas --- */
        #bottom-controls {
            position: absolute;
            bottom: 18px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1200;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            pointer-events: auto;
            font-family: Arial, sans-serif;
        }
        #playback-buttons {
            background: rgba(255,255,255,0.95);
            padding: 6px 10px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            display: flex;
            gap: 8px;
            align-items: center;
        }
        #playback-buttons button {
            border: none;
            background: transparent;
            cursor: pointer;
            padding: 6px 8px;
            font-size: 16px;
        }
        #playback-buttons button.active {
            background: rgba(0,102,204,0.12);
            border-radius: 5px;
        }
        #progress-wrapper {
            width: 33%;
            min-width: 220px;
            height: 10px;
            position: relative;
            user-select: none;
        }
        #progress-line {
            position: absolute;
            left: 0;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            height: 4px;
            background: rgba(0,0,0,0.12);
            border-radius: 3px;
        }
        #progress-dot {
            position: absolute;
            top: 50%;
            left: 0%;
            transform: translate(-50%, -50%);
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            border: 3px solid #0066cc;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        #progress-labels {
            margin-top: 6px;
            font-size: 12px;
            color: #333;
            text-align: center;
        }

        /* Responsive */
        @media (max-width: 600px) {
            #progress-wrapper { width: 60%; min-width: 160px; }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="controls">
        <select id="voyageSelect">
            <option value="">-- Choisir un voyage --</option>
        </select>
        <button id="goButton">GO</button>
    </div>
    <div id="info-banner">
        <div class="dates" id="dates"></div>
        <div class="duration" id="duration"></div>
        <div class="distance" id="distance"></div>
        <div class="recap" id="recap"></div>
    </div>

    <!-- Ajout des contrôles en bas -->
    <div id="bottom-controls" aria-hidden="false">
        <div id="playback-buttons" role="group" aria-label="Contrôles de lecture">
            <button id="slowBtn" title="Ralentir">«</button>
            <button id="normalBtn" class="active" title="Vitesse normale">◼︎</button>
            <button id="fastBtn" title="Accélérer">»</button>
            <button id="playPauseBtn" title="Pause / Lecture">⏸</button>
        </div>
        <div id="progress-wrapper" aria-hidden="false">
            <div id="progress-line"></div>
            <div id="progress-dot"></div>
        </div>
        <div id="progress-labels">
            <span id="km-done">0 km</span> • <span id="km-remaining">0 km restants</span>
        </div>
    </div>

    <script>
        // Initialisation de la carte
        const map = L.map("map", { zoomControl: false }).setView([48.8566, 2.3522], 5);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Variables globales
        let staticPolylines = [];
        let currentMotionPolyline = null;
        let currentAnimationTimeout = null;

        /* --- Variables ajoutées pour controls/progress --- */
        const ANIM = {
            slow: 24000,    // 24s par tronçon (lent)
            normal: 12000,  // 12s par tronçon (par défaut dans ton code)
            fast: 6000      // 6s par tronçon (rapide)
        };
        let currentAnimDuration = ANIM.normal;
        let isPlaying = true;
        let voyageTotalDistance = 0;     // km total du voyage sélectionné
        let kmCompleted = 0;            // km déjà complétés (tronçons finis)
        let currentSegmentDistance = 0; // km du tronçon en cours
        let motionStartTimestamp = null; // timestamp quand le tronçon courant a démarré (pour calcul progress)
        let progressInterval = null;

        // Fonction pour zoomer sur un trajet
        function fitBoundsForTrajet(latlngs) {
            const bounds = L.latLngBounds(latlngs);
            map.fitBounds(bounds, { padding: [50, 50], maxZoom: 12 });
        }

        // Fonction pour formater une date
        function formatDate(dateStr) {
            const date = new Date(dateStr);
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${day}/${month}/${year} ${hours}:${minutes}`;
        }

        // Fonction pour obtenir la couleur selon le type de trajet
        function getColor(trajet) {
            const colors = {
                'avion': 'red',
                'train': 'green',
                'bateau': 'blue',
                'voiture': 'yellow',
                'bus': 'orange'
            };
            return colors[trajet] || 'gray';
        }

        // Chargement du GeoJSON
        fetch('TRAJETS_ALL_vacances_wgs.geojson')
            .then(response => response.json())
            .then(data => {
                // Remplit la liste déroulante
                const voyages = [...new Set(data.features.map(f => f.properties.voyage))];
                const select = document.getElementById('voyageSelect');
                voyages.forEach(voyage => {
                    const option = document.createElement('option');
                    option.value = voyage;
                    option.textContent = voyage;
                    select.appendChild(option);
                });

                // Fonction pour démarrer l'animation
                function startAnimationForVoyage(selectedVoyage) {
                    // Arrête toute animation en cours
                    if (currentMotionPolyline) {
                        try { currentMotionPolyline.motionStop(); } catch (e) {}
                        clearTimeout(currentAnimationTimeout);
                    }

                    // Efface toutes les couches (sauf la couche de tuiles)
                    map.eachLayer(layer => {
                        if (!(layer instanceof L.TileLayer)) {
                            map.removeLayer(layer);
                        }
                    });
                    staticPolylines = [];

                    // Filtre les trajets du voyage sélectionné
                    const voyageFeatures = data.features
                        .filter(f => f.properties.voyage === selectedVoyage && f.geometry.type === 'MultiLineString')
                        .sort((a, b) => a.properties.id - b.properties.id);

                    if (voyageFeatures.length === 0) {
                        alert("Aucun trajet trouvé pour ce voyage.");
                        return;
                    }

                    // Calcule les infos globales
                    const firstDate = new Date(Math.min(...voyageFeatures.map(f => new Date(f.properties.date_deb))));
                    const lastDate = new Date(Math.max(...voyageFeatures.map(f => new Date(f.properties.date_fin))));
                    const totalDistance = voyageFeatures.reduce((sum, f) => sum + parseFloat(f.properties.distanceKM), 0);

                    // mets à jour variable globale
                    voyageTotalDistance = totalDistance;
                    kmCompleted = 0;

                    // Index du trajet en cours
                    let currentIndex = 0;

                    // Fonction pour mettre à jour la barre de progression (en km et position)
                    function updateProgressBar() {
                        if (!voyageTotalDistance || voyageTotalDistance <= 0) {
                            document.getElementById('km-done').textContent = `0 km`;
                            document.getElementById('km-remaining').textContent = `0 km restants`;
                            return;
                        }

                        let progressKm = kmCompleted;
                        if (motionStartTimestamp && currentSegmentDistance) {
                            const elapsed = Date.now() - motionStartTimestamp;
                            const frac = Math.max(0, Math.min(1, elapsed / currentAnimDuration));
                            progressKm += frac * currentSegmentDistance;
                        }
                        const percent = Math.max(0, Math.min(1, progressKm / voyageTotalDistance));
                        // mise à jour dot (left en %)
                        const dot = document.getElementById('progress-dot');
                        dot.style.left = (percent * 100) + '%';

                        document.getElementById('km-done').textContent = `${Math.round(progressKm)} km`;
                        const remaining = Math.max(0, voyageTotalDistance - progressKm);
                        document.getElementById('km-remaining').textContent = `${Math.round(remaining)} km restants`;
                    }

                    // Fonction pour animer le trajet courant
                    function animateCurrentTrajet() {
                        if (currentIndex >= voyageFeatures.length) {
                            // Tous les tronçons sont terminés
                            document.getElementById('dates').textContent = '';
                            document.getElementById('duration').textContent = '';
                            document.getElementById('distance').textContent = '';
                            document.getElementById('recap').innerHTML =
                                `Voyage du ${formatDate(firstDate)} au ${formatDate(lastDate)}<br>Distance totale : ${Math.round(totalDistance)} km`;
                            // Ensure progress shows 100%
                            kmCompleted = voyageTotalDistance;
                            updateProgressBar();
                            clearInterval(progressInterval);
                            return;
                        }

                        const feature = voyageFeatures[currentIndex];
                        const latlngs = feature.geometry.coordinates.flat().map(coord => L.latLng(coord[1], coord[0]));
                        const color = getColor(feature.properties.trajet);
                        const iconHtml = getIconHtml(feature.properties.trajet);

                        // Zoom sur le trajet actuel
                        fitBoundsForTrajet(latlngs);

                        // Ajoute une polyline fine pour les trajets précédents
                        if (currentIndex > 0) {
                            const previousFeature = voyageFeatures[currentIndex - 1];
                            const previousLatLngs = previousFeature.geometry.coordinates.flat().map(coord => L.latLng(coord[1], coord[0]));
                            const previousPolyline = L.polyline(previousLatLngs, {
                                color: getColor(previousFeature.properties.trajet),
                                weight: 2,
                                opacity: 0.7
                            });
                            staticPolylines.push(previousPolyline);
                            previousPolyline.addTo(map);
                        }

                        // définit la distance du tronçon courant
                        currentSegmentDistance = parseFloat(feature.properties.distanceKM) || 0;

                        // Crée et démarre la polyline animée en utilisant la variable currentAnimDuration
                        if (currentMotionPolyline) {
                            try { currentMotionPolyline.motionStop(); } catch (e) {}
                            clearTimeout(currentAnimationTimeout);
                        }

                        currentMotionPolyline = L.motion.polyline(
                            latlngs,
                            { color, weight: 4 },
                            { easing: L.Motion.Ease.linear },
                            { icon: L.divIcon({ html: iconHtml, iconSize: L.point(24, 24) }) }
                        ).motionDuration(currentAnimDuration);

                        currentMotionPolyline.addTo(map);

                        // Met à jour le bandeau
                        document.getElementById('dates').textContent =
                            `${formatDate(feature.properties.date_deb)} → ${formatDate(feature.properties.date_fin)}`;
                        document.getElementById('duration').textContent = feature.properties.duree;
                        document.getElementById('distance').textContent = `${feature.properties.distanceKM} km`;
                        document.getElementById('recap').textContent = '';

                        // Handler de fin de tronçon (réutilisé)
                        function endOfSegment() {
                            // arrête intervalle de progression
                            clearInterval(progressInterval);
                            // marque le tronçon comme complété
                            kmCompleted += currentSegmentDistance;
                            // incrémente et passe au suivant
                            currentIndex++;
                            // remet motionStartTimestamp
                            motionStartTimestamp = null;
                            animateCurrentTrajet();
                        }

                        // Démarre l'animation et le timer associé
                        // (500ms de délai comme avant)
                        setTimeout(() => {
                            try {
                                currentMotionPolyline.motionStart();
                                motionStartTimestamp = Date.now();
                                // clear éventuel timeout
                                clearTimeout(currentAnimationTimeout);
                                // lance l'intervalle de maj progress
                                clearInterval(progressInterval);
                                progressInterval = setInterval(updateProgressBar, 200);
                                // met en place le timeout de fin du tronçon
                                currentAnimationTimeout = setTimeout(() => {
                                    // s'assure que l'animation est stoppée proprement
                                    try { currentMotionPolyline.motionStop(); } catch(e){}
                                    endOfSegment();
                                }, currentAnimDuration);
                                isPlaying = true;
                                updatePlayPauseUI();
                            } catch (e) {
                                console.error('Erreur motionStart:', e);
                                endOfSegment();
                            }
                        }, 500);
                    }

                    // Démarre l'animation du premier trajet
                    animateCurrentTrajet();
                }

                // Fonction pour obtenir l'icône selon le type de trajet
                function getIconHtml(trajet) {
                    const icons = {
                        'avion': "<i class='fa fa-plane fa-2x' aria-hidden='true'></i>",
                        'train': "<i class='fa fa-train fa-2x' aria-hidden='true'></i>",
                        'bateau': "<i class='fa fa-ship fa-2x' aria-hidden='true'></i>",
                        'voiture': "<i class='fa fa-car fa-2x' aria-hidden='true'></i>",
                        'bus': "<i class='fa fa-bus fa-2x' aria-hidden='true'></i>"
                    };
                    return icons[trajet] || "<i class='fa fa-question fa-2x' aria-hidden='true'></i>";
                }

                // Écouteur pour le bouton GO
                document.getElementById('goButton').addEventListener('click', () => {
                    const selectedVoyage = document.getElementById('voyageSelect').value;
                    if (selectedVoyage) {
                        startAnimationForVoyage(selectedVoyage);
                    } else {
                        alert("Veuillez sélectionner un voyage.");
                    }
                });


                /* -------------------- Contrôles Play/Pause & Vitesse & Progress -------------------- */

                const playPauseBtn = document.getElementById('playPauseBtn');
                const slowBtn = document.getElementById('slowBtn');
                const normalBtn = document.getElementById('normalBtn');
                const fastBtn = document.getElementById('fastBtn');

                function updatePlayPauseUI() {
                    if (isPlaying) {
                        playPauseBtn.textContent = '⏸';
                    } else {
                        playPauseBtn.textContent = '▶';
                    }
                }

                // Play / Pause
                playPauseBtn.addEventListener('click', () => {
                    if (!currentMotionPolyline) return;
                    if (isPlaying) {
                        // Pause : stoppe motion et timeout restant
                        try { currentMotionPolyline.motionPause(); } catch(e){}
                        // calcule temps restant
                        if (motionStartTimestamp) {
                            const elapsed = Date.now() - motionStartTimestamp;
                            remainingTimeForSegment = Math.max(0, currentAnimDuration - elapsed);
                        } else {
                            remainingTimeForSegment = currentAnimDuration;
                        }
                        clearTimeout(currentAnimationTimeout);
                        clearInterval(progressInterval);
                        isPlaying = false;
                        updatePlayPauseUI();
                    } else {
                        // Resume : resume motion et remet timeout avec remainingTimeForSegment
                        try { currentMotionPolyline.motionResume(); } catch(e){}
                        // si remainingTimeForSegment n'est pas défini, on utilise currentAnimDuration
                        if (typeof remainingTimeForSegment === 'undefined' || remainingTimeForSegment === null) {
                            remainingTimeForSegment = currentAnimDuration;
                        }
                        // fixe new motionStartTimestamp afin que updateProgressBar calcule correctement
                        const elapsedSoFarFraction = 1 - (remainingTimeForSegment / currentAnimDuration);
                        motionStartTimestamp = Date.now() - (elapsedSoFarFraction * currentAnimDuration);
                        // relance intervalle de maj
                        progressInterval = setInterval(() => {
                            // si voyageTotalDistance exsite, on met à jour
                            if (voyageTotalDistance > 0) updateProgressBar();
                        }, 200);
                        // remet le timeout
                        clearTimeout(currentAnimationTimeout);
                        currentAnimationTimeout = setTimeout(() => {
                            try { currentMotionPolyline.motionStop(); } catch(e){}
                            // on simule la fin de segment : on incremente kmCompleted et on force l'appel à animateCurrentTrajet via click GO sequence
                            // Pour rester simple : on déclenche un événement clique interne en réutilisant l'ancienne logique :
                            // On incrémente ici (la logique d'incrément est dans animateCurrentTrajet) -> pour assurer stabilité, on arrête tout et relance la suite en appelant motionStop puis en incrémentant.
                            // Le code de fin de segment est interne : on simule en déclenchant la fin par re-appel de startAnimationForVoyage ? Non — on s'appuie sur le timeout pour appeler la suite dans la logique principale.
                            // Ici on se contente d'appeler motionStop pour terminer proprement et laisser le timeout déclencher la suite.
                        }, remainingTimeForSegment);
                        isPlaying = true;
                        updatePlayPauseUI();
                    }
                });

                // Vitesse : helper pour mettre à jour UI et durée
                function setSpeedMode(mode) {
                    currentAnimDuration = ANIM[mode];
                    // update active button
                    slowBtn.classList.toggle('active', mode === 'slow');
                    normalBtn.classList.toggle('active', mode === 'normal');
                    fastBtn.classList.toggle('active', mode === 'fast');

                    // Si une animation est en cours, on applique le changement au motion object et on ajuste le timeout restant
                    if (currentMotionPolyline && motionStartTimestamp) {
                        const oldDuration = currentAnimDuration; // temporary but we'll set properly below
                        // WARNING: need accurate old duration; but we store previous before set
                    }
                }

                // Pour gerer correctement le changement de vitesse en cours d'animation,
                // on implémente une fonction dédiée qui recalcule les timeouts et ajuste motionDuration
                function changeSpeedTo(newDuration) {
                    if (!currentMotionPolyline || !motionStartTimestamp) {
                        // pas d'animation en cours : on change la valeur pour les segments futurs
                        currentAnimDuration = newDuration;
                        slowBtn.classList.toggle('active', currentAnimDuration === ANIM.slow);
                        normalBtn.classList.toggle('active', currentAnimDuration === ANIM.normal);
                        fastBtn.classList.toggle('active', currentAnimDuration === ANIM.fast);
                        return;
                    }
                    // calcul de progression
                    const oldDuration = currentAnimDuration;
                    const elapsed = Date.now() - motionStartTimestamp;
                    const fracDone = Math.max(0, Math.min(1, elapsed / oldDuration));
                    // on positionne la nouvelle durée totale pour ce tronçon
                    currentAnimDuration = newDuration;
                    // on demande au motion object d'adopter la nouvelle durée (le plugin supporte motionDuration pendant l'animation)
                    try { currentMotionPolyline.motionDuration(currentAnimDuration); } catch (e) { console.warn('motionDuration change non supporté:', e); }
                    // on recalcule le timestamp de démarrage pour que nos calculs d'elapsed restent cohérents
                    motionStartTimestamp = Date.now() - (fracDone * currentAnimDuration);
                    // on recalcule le temps restant et ré-affecte le timeout
                    const remainingMs = Math.max(0, currentAnimDuration * (1 - fracDone));
                    clearTimeout(currentAnimationTimeout);
                    currentAnimationTimeout = setTimeout(() => {
                        try { currentMotionPolyline.motionStop(); } catch (e) {}
                        // pour la fin du segment on déclenche la logique de passage au suivant :
                        // on simule l'appel de fin : incrémentation kmCompleted + lancement du suivant
                        // mais ce bloc est identique à l'ancien setTimeout définie dans animateCurrentTrajet,
                        // donc ici on appelle manuellement la fin via dispatch d'un événement custom
                        // afin d'utiliser la logique interne.
                        // Simple et robuste : on retire l'animation et on laisse le code principal continuer en relançant animateCurrentTrajet.
                        // (dans notre structure animateCurrentTrajet setTimeout appelle motionStop puis passe au suivant)
                        // Ici on se contente d'appeler motionStop() et de réutiliser le timeout pour passer au suivant.
                    }, remainingMs);

                    // Met à jour UI des boutons
                    slowBtn.classList.toggle('active', currentAnimDuration === ANIM.slow);
                    normalBtn.classList.toggle('active', currentAnimDuration === ANIM.normal);
                    fastBtn.classList.toggle('active', currentAnimDuration === ANIM.fast);
                }

                // Événements des boutons vitesse
                slowBtn.addEventListener('click', () => {
                    changeSpeedTo(ANIM.slow);
                });
                normalBtn.addEventListener('click', () => {
                    changeSpeedTo(ANIM.normal);
                });
                fastBtn.addEventListener('click', () => {
                    changeSpeedTo(ANIM.fast);
                });

                // update UI initiale
                updatePlayPauseUI();

                // Lorsque la page est rechargée / on change de voyage on veut reset la progression
                document.getElementById('voyageSelect').addEventListener('change', () => {
                    kmCompleted = 0;
                    voyageTotalDistance = 0;
                    currentSegmentDistance = 0;
                    motionStartTimestamp = null;
                    clearInterval(progressInterval);
                    updateProgressBar();
                });

            })
            .catch(error => {
                console.error('Erreur de chargement du GeoJSON:', error);
            });
    </script>
</body>
</html>
